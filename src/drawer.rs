use glium::Surface;

// make the buffers for the renderer
fn make_buffers(
    display: &glium::Display,
    width: u32,
    height: u32,
) -> (
    glium::Texture2d,
    [glium::Texture2d; 4],
    [glium::Texture2d; 4],
) {
    let main_image = glium::Texture2d::empty_with_format(
        display,
        glium::texture::UncompressedFloatFormat::F32F32F32F32,
        glium::texture::MipmapsOption::AutoGeneratedMipmaps,
        width,
        height,
    )
    .expect("failed to make texture");

    let buffer_images = [
        glium::Texture2d::empty_with_format(
            display,
            glium::texture::UncompressedFloatFormat::F32F32F32F32,
            glium::texture::MipmapsOption::AutoGeneratedMipmaps,
            width,
            height,
        )
        .expect("failed to make texture"),
        glium::Texture2d::empty_with_format(
            display,
            glium::texture::UncompressedFloatFormat::F32F32F32F32,
            glium::texture::MipmapsOption::AutoGeneratedMipmaps,
            width,
            height,
        )
        .expect("failed to make texture"),
        glium::Texture2d::empty_with_format(
            display,
            glium::texture::UncompressedFloatFormat::F32F32F32F32,
            glium::texture::MipmapsOption::AutoGeneratedMipmaps,
            width,
            height,
        )
        .expect("failed to make texture"),
        glium::Texture2d::empty_with_format(
            display,
            glium::texture::UncompressedFloatFormat::F32F32F32F32,
            glium::texture::MipmapsOption::AutoGeneratedMipmaps,
            width,
            height,
        )
        .expect("failed to make texture"),
    ];

    let backbuffer_images = [
        glium::Texture2d::empty_with_format(
            display,
            glium::texture::UncompressedFloatFormat::F32F32F32F32,
            glium::texture::MipmapsOption::AutoGeneratedMipmaps,
            width,
            height,
        )
        .expect("failed to make texture"),
        glium::Texture2d::empty_with_format(
            display,
            glium::texture::UncompressedFloatFormat::F32F32F32F32,
            glium::texture::MipmapsOption::AutoGeneratedMipmaps,
            width,
            height,
        )
        .expect("failed to make texture"),
        glium::Texture2d::empty_with_format(
            display,
            glium::texture::UncompressedFloatFormat::F32F32F32F32,
            glium::texture::MipmapsOption::AutoGeneratedMipmaps,
            width,
            height,
        )
        .expect("failed to make texture"),
        glium::Texture2d::empty_with_format(
            display,
            glium::texture::UncompressedFloatFormat::F32F32F32F32,
            glium::texture::MipmapsOption::AutoGeneratedMipmaps,
            width,
            height,
        )
        .expect("failed to make texture"),
    ];

    (main_image, buffer_images, backbuffer_images)
}

// load a shader program
pub fn load_program(display: &glium::Display, path: &str) -> Option<glium::program::Program> {
    // load the file
    let shader = match std::fs::read_to_string(path) {
        Ok(x) => x,
        Err(reason) => {
            println!("Failed to load shader: {:?}", reason);
            return None;
        }
    };

    // load build-in shaders
    let vertex_shader = include_str!("vertex.vert");

    // format the shader so it can go from shadertoy -> opengl
    let formatted_shader = format!(include_str!("fragment.frag"), shader);

    // make the shader input, because from_source does not give the ability to set srgb output
    let shader_input = glium::program::ProgramCreationInput::SourceCode {
        vertex_shader,
        tessellation_control_shader: None,
        tessellation_evaluation_shader: None,
        geometry_shader: None,
        fragment_shader: &formatted_shader,
        transform_feedback_varyings: None,
        outputs_srgb: true,
        uses_point_size: false,
    };

    // make the program to run the shader
    match glium::program::Program::new(display, shader_input) {
        Ok(x) => Some(x),
        Err(reason) => {
            let error = match reason {
                glium::program::ProgramCreationError::CompilationError(e, _) => e,
                x => format!("Error: {:?}", x),
            };

            println!("Failed to compile shader:\n{}", error);
            None
        }
    }
}


// one iChannel and it's needed data
pub enum Channel {
    // texture to use for this channel
    Texture(glium::Texture2d),
    // buffer index to use
    Buffer(usize),
    // or the keyboard texture
    Keyboard,
    // or nothing
    None,
}

impl Channel {
	// select a texture for the channel
    fn get_texture<'a>(
        &'a self,
        buffers: &'a [glium::Texture2d; 4],
        empty: &'a glium::Texture2d,
    ) -> &'a glium::Texture2d {
        match self {
            Channel::Texture(x) => x,
            &Channel::Buffer(i) => &buffers[i],
            _ => empty,
        }
    }
}

#[derive(Copy, Clone)]
struct Vert {
    pos: [f32; 2],
}
glium::implement_vertex!(Vert, pos);

/// helper to actually draw the shaders
pub struct Drawer {
    main_image: glium::Texture2d,
    buffer_images: [glium::Texture2d; 4],
    backbuffer_images: [glium::Texture2d; 4],
    empty: glium::Texture2d,
    main_program: glium::Program,
    pub main_image_program: Option<glium::Program>,
    pub buffer_programs: [Option<glium::Program>; 4],
    pub channels: [[Channel; 4]; 5],
    vertex_buffer: glium::VertexBuffer<Vert>,
    pub width: u32,
    pub height: u32,
}

impl Drawer {
    pub fn new(
        display: &glium::Display,
        width: u32,
        height: u32,
        scale: f32,
    ) -> Self {
        // vertex buffer
        // not that important here as it's just a fullscreen quad
        let vertex_buffer = {
            glium::VertexBuffer::new(
                display,
                &[
                    Vert { pos: [-1.0, -1.0] },
                    Vert { pos: [3.0, -1.0] },
                    Vert { pos: [-1.0, 3.0] },
                ],
            )
            .unwrap()
        };

		// program to copy from the render target to the output
        let main_program = glium::program::Program::new(
            display,
            glium::program::ProgramCreationInput::SourceCode {
                vertex_shader: "
				#version 140
	
				in vec2 pos;
				out vec2 vpos;
				
				void main() {
					// just set it to the position
					gl_Position = vec4(pos, 0.0, 1.0);
				
					// shadertoy's UV goes from (0, 0) to (1, 1), while gl's screen goes from (-1, -1) to (1, 1)
					vpos = pos * 0.5 + 0.5;
				}
				",
                tessellation_control_shader: None,
                tessellation_evaluation_shader: None,
                geometry_shader: None,
                fragment_shader: "
				#version 140

				in vec2 vpos;
				out vec4 fragcol;

				// where we get our image from
				uniform sampler2D main_image;


				// double braces to escape rust's formatter
				void main() {

					// just copy it
					fragcol = texture(main_image, vpos);

				}
				",
                transform_feedback_varyings: None,
                outputs_srgb: true,
                uses_point_size: false,
            },
        )
        .unwrap();

		// make the buffer images
        let (main_image, buffer_images, backbuffer_images) = make_buffers(
            display,
            (width as f32 * scale) as u32,
            (height as f32 * scale) as u32,
        );

		// empty texture
        let empty = glium::Texture2d::empty(display, 1, 1).unwrap();

		// TODO KEYBOARD

		// and channels
		// ugly, but we can't implement copy for this
        let channels = [
            [Channel::None, Channel::None, Channel::None, Channel::None],
            [Channel::None, Channel::None, Channel::None, Channel::None],
            [Channel::None, Channel::None, Channel::None, Channel::None],
            [Channel::None, Channel::None, Channel::None, Channel::None],
            [Channel::None, Channel::None, Channel::None, Channel::None],
        ];

        Self {
            main_image,
            buffer_images,
            backbuffer_images,
            empty,
            channels,
            main_program,
            main_image_program: None,
            buffer_programs: [None, None, None, None],
            vertex_buffer,
            width: (width as f32 * scale) as u32,
            height: (height as f32 * scale) as u32,
        }
    }

    pub fn draw(
        &mut self,
        display: &glium::Display,
        time: f32,
        frame: i32,
        mouse_position: (u32, u32),
        mouse_input: (bool, bool),
        scale: f32,
    ) {
        // get the image size
        let resolution = display.get_framebuffer_dimensions();

        // if the resolution changed, remake our buffers
        if (
            (resolution.0 as f32 * scale) as u32,
            (resolution.1 as f32 * scale) as u32,
        ) != (
            (self.width as f32 * scale) as u32,
            (self.height as f32 * scale) as u32,
        ) {
            self.width = (resolution.0 as f32 * scale) as u32;
            self.height = (resolution.1 as f32 * scale) as u32;
            let (main_image, buffer_images, backbuffer_images) =
                make_buffers(display, self.width, self.height);
            self.main_image = main_image;
            self.buffer_images = buffer_images;
            self.backbuffer_images = backbuffer_images;
        }

        // draw the frame
        let targets = [(&self.main_image, &self.main_image_program)];

		// for all channels/buffers
        for (i, (image, program)) in targets.into_iter().enumerate() {

			// make the targets
			let mut target = glium::framebuffer::SimpleFrameBuffer::new(display, image)
                .expect("Failed to make framebuffer");

            // make the uniforms and inputs
            let uniforms = glium::uniform! {
                iResolution: [resolution.0 as f32, resolution.1 as f32, resolution.1 as f32 / resolution.0 as f32],
                iFrame: frame as i32,
                iTime: time as f32,
                iMouse: [mouse_position.0 as f32, mouse_position.1 as f32, if mouse_input.0 { 1.0 } else { 0.0 }, if mouse_input.1 { 1.0 } else { 0.0 }],
                iChannel0: self.channels[i][0].get_texture(&self.backbuffer_images, &self.empty),
            };

            // only draw if the program is valid
            if let Some(prog) = program {
                target
                    .draw(
                        &self.vertex_buffer,
                        glium::index::NoIndices(glium::index::PrimitiveType::TriangleStrip),
                        &prog,
                        &uniforms,
                        &Default::default(),
                    )
                    .unwrap();
            } else {
                target.clear_color(0.0, 0.0, 0.0, 0.0);
            }
        }

        // and draw to the main screen
        let mut target = display.draw();
        let uniform = glium::uniform! {
            main_image: self.main_image.sampled().wrap_function(glium::uniforms::SamplerWrapFunction::Clamp),
        };

        target
            .draw(
                &self.vertex_buffer,
                glium::index::NoIndices(glium::index::PrimitiveType::TriangleStrip),
                &self.main_program,
                &uniform,
                &Default::default(),
            )
            .unwrap();
        target.finish().unwrap();

        // swap buffers
        std::mem::swap(&mut self.buffer_images, &mut self.backbuffer_images);
    }
}
