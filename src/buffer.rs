use glium::Surface;

// vertex buffer
#[derive(Copy, Clone)]
pub struct Vert {
    pub pos: [f32; 2],
}
glium::implement_vertex!(Vert, pos);

// one iChannel and it's needed data
pub enum Channel {
    // texture to use for this channel
    Texture(glium::Texture2d),
    // buffer index to use
    Buffer(usize),
    // or the keyboard texture
    Keyboard,
    // or nothing
    None,
}

impl Channel {
    // select a texture for the channel
    fn get_texture<'a>(&'a self, buffers: &'a [glium::Texture2d], empty: &'a glium::Texture2d) -> &'a glium::Texture2d {
        match self {
            Channel::Texture(x) => x,
            Channel::Buffer(i) => &buffers[*i],
            _ => empty,
        }
    }
}

pub struct Buffer {
    // program of the buffer
    pub program: Option<glium::Program>,

    // buffers
    pub buffer: glium::Texture2d,
    vertex_buffer: glium::VertexBuffer<Vert>,

    // size
    width: u32,
    height: u32,

    // channels
    channels: [Channel; 4],
}

impl Buffer {
    pub fn new(
        display: &glium::Display,
        width: u32,
        height: u32,
        program: Option<glium::Program>,
        channels: [Channel; 4],
    ) -> (Self, glium::Texture2d) {
        (
            Self {
                program,
                channels,
                width,
                height,
                vertex_buffer: glium::VertexBuffer::new(
                    display,
                    &[
                        Vert { pos: [-1.0, -1.0] },
                        Vert { pos: [3.0, -1.0] },
                        Vert { pos: [-1.0, 3.0] },
                    ],
                )
                .expect("failed to make vertex buffer"),
                buffer: glium::Texture2d::empty_with_format(
                    display,
                    glium::texture::UncompressedFloatFormat::F32F32F32F32,
                    glium::texture::MipmapsOption::AutoGeneratedMipmaps,
                    width,
                    height,
                )
                .expect("failed to make texture"),
            },
            glium::Texture2d::empty_with_format(
                display,
                glium::texture::UncompressedFloatFormat::F32F32F32F32,
                glium::texture::MipmapsOption::AutoGeneratedMipmaps,
                width,
                height,
            )
            .expect("failed to make texture"),
        )
    }

    pub fn draw(
        &mut self,
        display: &glium::Display,
		index: usize,
        backbuffers: &mut [glium::Texture2d; 5],
        time: f32,
        frame: i32,
        mouse_position: (u32, u32),
        mouse_input: (bool, bool),
        scale: f32,
        empty: &glium::Texture2d,
    ) {
        // get the image size
        let resolution = display.get_framebuffer_dimensions();

        // remake framebuffers if needed
        if (
            (resolution.0 as f32 * scale) as u32,
            (resolution.1 as f32 * scale) as u32,
        ) != (
            (self.width as f32 * scale) as u32,
            (self.height as f32 * scale) as u32,
        ) {
            self.width = (resolution.0 as f32 * scale) as u32;
            self.height = (resolution.1 as f32 * scale) as u32;

            self.buffer = glium::Texture2d::empty_with_format(
                display,
                glium::texture::UncompressedFloatFormat::F32F32F32F32,
                glium::texture::MipmapsOption::AutoGeneratedMipmaps,
                self.width,
                self.height,
            )
            .expect("failed to make texture");
            backbuffers[index] = glium::Texture2d::empty_with_format(
                display,
                glium::texture::UncompressedFloatFormat::F32F32F32F32,
                glium::texture::MipmapsOption::AutoGeneratedMipmaps,
                self.width,
                self.height,
            )
            .expect("failed to make texture");
        }

        // make the targets, to the backbuffer, so swapping is easier
        let mut target = glium::framebuffer::SimpleFrameBuffer::new(display, &self.buffer)
            .expect("Failed to make framebuffer");

        // make the uniforms and inputs
        let uniforms = glium::uniform! {
            iResolution: [resolution.0 as f32, resolution.1 as f32, resolution.1 as f32 / resolution.0 as f32],
            iFrame: frame as i32,
            iTime: time as f32,
            iMouse: [mouse_position.0 as f32, mouse_position.1 as f32, if mouse_input.0 { 1.0 } else { 0.0 }, if mouse_input.1 { 1.0 } else { 0.0 }],
            iChannel0: self.channels[0].get_texture(&backbuffers[1..], empty),
            iChannel1: self.channels[1].get_texture(&backbuffers[1..], empty),
            iChannel2: self.channels[2].get_texture(&backbuffers[1..], empty),
            iChannel3: self.channels[3].get_texture(&backbuffers[1..], empty),
        };

        // only draw if the program is valid
        if let Some(prog) = &self.program {
            target
                .draw(
                    &self.vertex_buffer,
                    glium::index::NoIndices(glium::index::PrimitiveType::TriangleStrip),
                    &prog,
                    &uniforms,
                    &Default::default(),
                )
                .unwrap();
        } else {
            target.clear_color(0.0, 0.0, 0.0, 0.0);
        }

		
		// swap
		std::mem::swap(&mut self.buffer, &mut backbuffers[index]);
    }
}